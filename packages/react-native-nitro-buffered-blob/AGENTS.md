<!-- Parent: ../../AGENTS.md -->
<!-- Generated: 2026-02-15 | Updated: 2026-02-15 -->

# react-native-nitro-buffered-blob

## Purpose

A React Native native module that provides zero-copy buffered blob (file) I/O operations using Margelo's Nitro framework. Implements streaming file read/write, file system operations, file hashing, and downloads with progress callbacks. Built with Nitrogen codegen to generate C++, Swift, and Kotlin implementations from TypeScript specifications.

## Key Files

| File | Description |
|------|-------------|
| `package.json` | Package configuration with nitro-modules peer dependency, build scripts, and React Native Builder Bob targets |
| `nitro.json` | Nitrogen codegen configuration with C++ namespace, iOS/Android module names, and autolinking config |
| `tsconfig.json` / `tsconfig.build.json` | TypeScript compiler configuration with strict mode and react-native-strict-api |
| `NitroBufferedBlob.podspec` | CocoaPods pod specification for iOS integration, loads Nitrogen autolinking files |
| `react-native.config.js` | React Native CLI configuration (if present) |

## Subdirectories

| Directory | Purpose |
|-----------|---------|
| `src/` | TypeScript HybridObject interface specifications (.nitro.ts files) and barrel exports |
| `src/specs/` | Nitro spec files defining the native module contracts (BufferedBlobModule, NativeFileReader/Writer/Downloader, types) |
| `ios/` | Swift implementation of HybridObjects (HybridBufferedBlobModule, HybridNativeFileReader, HybridNativeFileWriter, HybridNativeDownloader) |
| `android/` | Kotlin implementation of HybridObjects, Gradle build config, C++ CMakeLists.txt, JNI adapter |
| `cpp/` | C++ implementation placeholder (typically empty; implementations in ios/ and android/ subdirs) |
| `nitrogen/` | Nitrogen codegen output directory with auto-generated specs and platform bridges (do NOT edit manually) |
| `lib/` | Compiled TypeScript output (generated by React Native Builder Bob) |

## For AI Agents

### Working In This Directory

This is a Nitro native module package. The workflow is:

1. **Edit TypeScript specs** (`src/specs/*.nitro.ts`) to define HybridObject interfaces
2. **Run `yarn nitrogen`** to codegen C++, Swift, and Kotlin specs into `nitrogen/generated/`
3. **Implement native code** in `ios/*.swift` and `android/*.kt` to match the generated specs
4. **Test** on both platforms using React Native integration tests

**Key constraint**: Never edit files in `nitrogen/generated/`. These are auto-generated by Nitrogen. Instead, modify the TypeScript specs and re-run codegen.

### File System Operations

- **HybridObject specs** are defined in `src/specs/*.nitro.ts`
- **Generated code** appears in `nitrogen/generated/` (shared/, ios/, android/) after running `yarn nitrogen`
- **iOS implementation** in `ios/` uses Swift and InputStream/OutputStream for streaming
- **Android implementation** in `android/` uses Kotlin and BufferedInputStream/BufferedOutputStream
- **JNI bridge** auto-generated in `nitrogen/generated/android/c++/` (do not edit)

### Testing Requirements

- TypeScript: `yarn typecheck` validates spec files and type safety
- No unit tests at this layer; integration testing done via React Native app
- Verify generated code compiles after running `yarn nitrogen`
- iOS: builds via CocoaPods autolinking
- Android: builds via Gradle with CMake

### Common Patterns

**Adding a new HybridObject:**
1. Create `src/specs/MyObject.nitro.ts` with interface extending `HybridObject<{ ios: 'swift'; android: 'kotlin' }>`
2. Run `yarn nitrogen` to generate specs
3. Implement in `ios/HybridMyObject.swift` and `android/HybridMyObject.kt`
4. Export from `src/index.ts`

**Zero-copy ArrayBuffer transfer:**
- Read returns `Promise<ArrayBuffer | undefined>` (EOF indicated by undefined)
- Write accepts `ArrayBuffer` directly; no serialization overhead
- Large buffers (>10MB) may need chunking logic in the consumer

**Streaming patterns:**
- `NativeFileReader.readNextChunk()` returns optional ArrayBuffer; check for undefined to detect EOF
- `NativeFileWriter.write(data)` returns bytes written; use for validation
- `NativeFileWriter.flush()` to ensure data is synced to disk

## Dependencies

### Internal
- `react-native-nitro-modules` (peer dependency) - Runtime HybridObject bridge
- `nitrogen` (dev dependency) - Codegen tool for TypeScript to C++/Swift/Kotlin

### External
- **iOS**: Foundation.framework, Combine (URLSession for downloads)
- **Android**: java.io (InputStream/OutputStream), okhttp3 (downloads), Kotlin stdlib
- **React Native**: >= 0.73 recommended for best Nitro support

### Build Tools
- `react-native-builder-bob` - Transpiles TypeScript and runs Nitrogen codegen
- Gradle 8.7.2 (Android)
- Xcode 16+ (iOS, via CocoaPods)
- TypeScript 5.9.2

## Architecture Notes

- **HybridObjects** are synchronous on the JS side (returned directly) but contain async methods for I/O
- **Stream factories** (openRead, openWrite, createDownload) return objects synchronously; actual I/O happens async
- **ArrayBuffer** is transferred zero-copy on both platforms via native bridges
- **Error handling**: Exceptions in native code marshal to JS Promise rejections
- **Thread safety**: Reader/Writer/Downloader objects are single-threaded; create separate instances for concurrent operations
- **Memory**: Large file operations should use streaming (readNextChunk) rather than loading entire files into ArrayBuffer

<!-- MANUAL: Add platform-specific setup instructions, known issues, or workarounds here. -->
